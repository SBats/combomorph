<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_human_run</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Init Char Variables
//////////////////////////////////
/*
image_speed = 0.1;

// Init Common constants
ySpeed = 0;
xSpeed = 0;
maxHeightAllowingJump = 16;
airResistance = 0.05;
waterResistance = 0.5;

canDash = true;
isDashing = false;
isGrabingWall = false;
jump_requested = false;
isOnASlope = false;
status = 'standing';

enum forms {
    human,
    rock,
    air,
    water,
    fire,
    source
};


enum humanConstants {
    grav = 0.4,
    maxVerticalSpeed = 16,
    jumpSpeed = 6,
    cutJumpSpeed = 6 / 4,
    runningSpeed = 0.2,
    maxRunningSpeed = 3,
    dashingSpeedCoeff = 1.5,
    dashingLength = 30,
    dashingRecovery = 60,
    reactivityDeceleration = 0.3,
    swimmingSpeed = 0.2,
    maxSwimmingSpeed = 3,
    flyingSpeed = 0,
    maxFlyingSpeed = 0,
    maxHorizontalSpeed = 16
}

enum rockConstants {
    grav = 0.8,
    maxVerticalSpeed = 16,
    jumpSpeed = 4,
    cutJumpSpeed = 4 / 4,
    runningSpeed = 0.1,
    maxRunningSpeed = 2,
    dashingSpeedCoeff = 3,
    dashingLength = 0,
    dashingRecovery = 0,
    reactivityDeceleration = 0.2,
    swimmingSpeed = 0.05,
    maxSwimmingSpeed = 1,
    flyingSpeed = 0,
    maxFlyingSpeed = 0,
    maxHorizontalSpeed = 16
}

enum airConstants {
    grav = 0,
    maxVerticalSpeed = 16,
    jumpSpeed = 4,
    cutJumpSpeed = 4,
    runningSpeed = 0,
    maxRunningSpeed = 12,
    dashingSpeedCoeff = 2,
    dashingLength = 60,
    dashingRecovery = 180,
    reactivityDeceleration = 0.4,
    swimmingSpeed = 0.05,
    maxSwimmingSpeed = 1,
    flyingSpeed = 0.3,
    maxFlyingSpeed = 6,
    maxHorizontalSpeed = 16
}

enum formConstants {
    human = humanConstants,
    rock = rockConstants,
    air = airConstants
}

currentForm = 'human';
currentFormConstants = formConstants.human;

*/


/*
// Init Human Form constants
humanConstants = ds_map_create();

humanConstants[? "grav"] = 0.4;
humanConstants[? "maxVerticalSpeed"] = 16;
humanConstants[? "jumpSpeed"] = 6;
humanConstants[? "cutJumpSpeed"] = -humanConstants[? "jumpSpeed"] / 4;
humanConstants[? "runningSpeed"] = 0.2;
humanConstants[? "maxRunningSpeed"] = 3;
humanConstants[? "dashingSpeedCoeff"] = 1.5;
humanConstants[? "dashingLength"] = 30;
humanConstants[? "dashingRecovery"] = 60;
humanConstants[? "reactivityDeceleration"] = 0.3;
humanConstants[? "swimmingSpeed"] = 0.2;
humanConstants[? "maxSwimmingSpeed"] = 3;
humanConstants[? "flyingSpeed"] = 0;
humanConstants[? "maxFlyingSpeed"] = 0;
humanConstants[? "maxHorizontalSpeed"] = 16;



// Init Rock Form constants
rockConstants = ds_map_create();

rockConstants[? "grav"] = 0.8;
rockConstants[? "maxVerticalSpeed"] = 16;
rockConstants[? "jumpSpeed"] = 4;
rockConstants[? "cutJumpSpeed"] = -rockConstants[? "jumpSpeed"] / 4;
rockConstants[? "runningSpeed"] = 0.1;
rockConstants[? "maxRunningSpeed"] = 2;
rockConstants[? "dashingSpeedCoeff"] = 3;
rockConstants[? "dashingLength"] = 0;
rockConstants[? "dashingRecovery"] = 0;
rockConstants[? "reactivityDeceleration"] = 0.2;
rockConstants[? "swimmingSpeed"] = 0.05;
rockConstants[? "maxSwimmingSpeed"] = 1;
rockConstants[? "flyingSpeed"] = 0;
rockConstants[? "maxFlyingSpeed"] = 0;
rockConstants[? "maxHorizontalSpeed"] = 16;


// Init Air Form constants
airConstants = ds_map_create();

airConstants[? "grav"] = 0;
airConstants[? "maxVerticalSpeed"] = 16;
airConstants[? "jumpSpeed"] = 4;
airConstants[? "cutJumpSpeed"] = -airConstants[? "jumpSpeed"] / 1;
airConstants[? "runningSpeed"] = 0;
airConstants[? "maxRunningSpeed"] = 12;
airConstants[? "dashingSpeedCoeff"] = 2;
airConstants[? "dashingLength"] = 60;
airConstants[? "dashingRecovery"] = 180;
airConstants[? "reactivityDeceleration"] = 0.4;
airConstants[? "swimmingSpeed"] = 0.05;
airConstants[? "maxSwimmingSpeed"] = 1;
airConstants[? "flyingSpeed"] = 0.3;
airConstants[? "maxFlyingSpeed"] = 6;
airConstants[? "maxHorizontalSpeed"] = 16;

formConstants[0] = humanConstants;
formConstants[1] = rockConstants;
formConstants[2] = airConstants;

formList[0] = 'human';
formList[1] = 'rock';
formList[2] = 'air';
//formList[3] = 'water';
//formList[4] = 'fire';
//formList[5] = 'source';

currentForm = 0;
currentFormConstants = formConstants[currentForm];
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Dash recovery
canDash = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Dashing length
isDashing = false;
alarm[1] = currentFormConstants[? "dashingRecovery"];
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Player's inputs
///////////////////////
/*
key_right = keyboard_check(vk_right);
key_left = -keyboard_check(vk_left);
key_down = keyboard_check(vk_down);
key_up = keyboard_check(vk_up);
key_dash = keyboard_check(vk_shift);
key_run = 1;
key_jump = keyboard_check_pressed(vk_space);
key_jump_longpress = keyboard_check(vk_space);
key_next_form = keyboard_check_pressed(ord('D'));
key_prev_form = keyboard_check_pressed(ord('Q'));
*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Character movement
//////////////////////////////////////////////////

///////////////////////
// Horizontal movement
///////////////////////

/*
hMove = key_right + key_left;

var speedToAdd = 0;
var oldXSpeed = xSpeed;
var crouchSlowingDown = 0;
var currentResistance;
var speedTypeValue;
var maxSpeedTypeValue;
var startingCoeff;
var groundObject = -1;
var waterObject = -1;


if (place_meeting(x, bbox_top, obj_water)) {
    waterObject = instance_place(x, bbox_top, obj_water);
    currentResistance = waterObject.objectFriction;
    speedTypeValue = currentFormConstants[? "swimmingSpeed"];
    maxSpeedTypeValue = currentFormConstants[? "maxSwimmingSpeed"];
    //startingCoeff = 1;
    status = 'swimming';
} else if (formList[currentForm] == 'air') {
    currentResistance = airResistance;
    speedTypeValue = currentFormConstants[? "flyingSpeed"];
    maxSpeedTypeValue = currentFormConstants[? "maxFlyingSpeed"];
    //startingCoeff = 0.8;
    status = 'flying';
} else {
    groundObject = instance_place(x, y + 1, par_ground);
    speedTypeValue = currentFormConstants[? "runningSpeed"];
    maxSpeedTypeValue = currentFormConstants[? "maxRunningSpeed"];
    if (groundObject != noone) {
        currentResistance = groundObject.objectFriction;
        //startingCoeff = currentResistance;
    } else {
        currentResistance = 0;
        //startingCoeff = 1;
    }
    
}

if ((canDash &amp;&amp; key_dash == 1) || isDashing) {
    status = 'dashing';
    var dashingLength = currentFormConstants[? "dashingLength"];
    if (dashingLength != 0 &amp;&amp; !isDashing) {
        canDash = false;
        isDashing = true;
        alarm[0] = dashingLength;
    }
}

if (status == 'dashing') {
    xSpeed += speedTypeValue * (key_run + 1) * currentFormConstants[? "dashingSpeedCoeff"] * hMove;
    if (xSpeed &gt; 0) {
        xSpeed = min(maxSpeedTypeValue * (key_run + 1) * currentFormConstants[? "dashingSpeedCoeff"], xSpeed);    
    }
    if (xSpeed &lt; 0) {
        xSpeed = max(-maxSpeedTypeValue * (key_run + 1) * currentFormConstants[? "dashingSpeedCoeff"], xSpeed);    
    }

} else {
    xSpeed += speedTypeValue * (key_run + 1) * hMove;
    if (xSpeed &gt; 0) {
        xSpeed = min(maxSpeedTypeValue * (key_run + 1), xSpeed);    
    }
    if (xSpeed &lt; 0) {
        xSpeed = max(-maxSpeedTypeValue * (key_run + 1), xSpeed);    
    }
}

if (waterObject != -1 &amp;&amp; waterObject != noone) {

} else if (groundObject != -1 &amp;&amp; groundObject != noone) {

    if (xSpeed != 0) {
        if (key_down == 1) {
            status = 'sliding';
            crouchSlowingDown = 1;
            xSpeed = oldXSpeed;
        } else {
            status = 'running';
        }
    } else {
        if (key_down == 1) {
            status = 'crouching';
            crouchSlowingDown = 1;
            xSpeed = 0;
        } else {
            status = 'standing';
        }
    }

} else {

}

if (xSpeed != 0) {
    if (sign(hMove) != sign(xSpeed)) {
        xSpeed += currentFormConstants[? "reactivityDeceleration"] * (key_run + 1) * hMove;
    }
    
    if (hMove == 0 || crouchSlowingDown) {
        if (xSpeed * sign(xSpeed) &lt; currentResistance) {
            xSpeed = 0;
        } else {
            xSpeed -= currentResistance * sign(xSpeed) / (1 + crouchSlowingDown);
        }
    }
    
}

// Limit hoizontal Speed
xSpeed = min(abs(xSpeed), currentFormConstants[? "maxHorizontalSpeed"]) * sign(xSpeed);


///////////////////////
// Vertical movement
///////////////////////

if (waterObject != -1 &amp;&amp; waterObject != noone) {
// Water context
    vMove = key_up - key_down;
    isGrabingWall = false;
    status = 'swimming';
    ySpeed += speedTypeValue * (key_run + 1) * -vMove;
    
    if (ySpeed &gt; 0) {
        ySpeed = min(maxSpeedTypeValue * (key_run + 1) , ySpeed);
    }
    
    if (ySpeed &lt; 0) {
        ySpeed = max(-maxSpeedTypeValue * (key_run + 1), ySpeed);
    }

    if (vMove == 0) {
        if (ySpeed * sign(ySpeed) &lt; waterObject.objectFriction) {
            ySpeed = 0;
        } else {
            ySpeed -= waterObject.objectFriction * sign(ySpeed);
        }
    }
           
    // If on the surface
    if (!place_meeting(x, bbox_top - ((bbox_bottom - bbox_top) / 2), obj_water)) {
        
        if (ySpeed &lt; 0) {
            ySpeed = 0;
        }
        
        //Toggle jump if jump is pressed or requested
        if (key_jump_longpress == 1) {
            ySpeed = -currentFormConstants[? "jumpSpeed"];
            status = 'jumping';
        }
    }
    
} else if (formList[currentForm] == 'air') {
// Air Context
    vMove = key_up - key_down;
    isGrabingWall = false;
    
    ySpeed += speedTypeValue * (key_run + 1) * -vMove;
    
    if (ySpeed &gt; 0) {
        ySpeed = min(maxSpeedTypeValue * (key_run + 1) , ySpeed);
    }
    
    if (ySpeed &lt; 0) {
        ySpeed = max(-maxSpeedTypeValue * (key_run + 1), ySpeed);
    }
    
    // Add friction if not pressing direction
    if (vMove == 0) {
        
        if (ySpeed * sign(ySpeed) &lt; airResistance) {
            ySpeed = 0;
        } else {
            ySpeed -= airResistance * sign(ySpeed);
        }
    }
    status = 'flying';
} else {
// Ground context

    // Record jump if close enough to ground
    if (place_meeting(x, y + maxHeightAllowingJump, par_ground) &amp;&amp; ySpeed &gt;=0 &amp;&amp; key_jump == 1) {
        jump_requested = true;
    }
    
    // If on the ground
    if (place_meeting(x, y + 8, par_ground)) {
        
        //Toggle jump if jump is pressed or requested
        if (key_jump == 1 || jump_requested) {
            jump_requested = false;
            ySpeed = -currentFormConstants[? "jumpSpeed"];
            if (key_run == 1) {
                ySpeed -= currentFormConstants[? "jumpSpeed"] / 4;
            }
            if (status != 'dashing') {
                status = 'jumping';
            }
        }

    } else {
        if (ySpeed &lt;= 0) {
            if (status != 'dashing') {
                status = 'jumping';
            }
        }
        if (ySpeed &gt; 0) {
            if (status != 'dashing') {
                status = 'falling';
            }
        }
    }
    
    // Air resistance
    if (xSpeed != 0 &amp;&amp; ySpeed &lt; 0 &amp;&amp; ySpeed &gt; -4) {
       xSpeed += -airResistance * sign(xSpeed);
    } 
    
    // Cut jump if stop pressing jump button
    if (key_jump_longpress == 0 &amp;&amp; ySpeed &lt; 0  &amp;&amp; ySpeed &lt; currentFormConstants[? "cutJumpSpeed"]) {
        ySpeed = currentFormConstants[? "cutJumpSpeed"];
    }
    
    // Apply gravity
    if (status == 'dashing') {
        ySpeed += currentFormConstants[? "grav"] / currentFormConstants[? "dashingSpeedCoeff"];
    } else {
        ySpeed += currentFormConstants[? "grav"];
    }    
    
    // Grab wall if falling and moving to it
    if (hMove != 0 &amp;&amp; ySpeed &gt;= 0 &amp;&amp; place_meeting(x + sign(hMove), y, par_wall)) {
        isGrabingWall = true;
    }
    
    // Keep wall sliding if grabing wall and not on the flour
    if (isGrabingWall) {
        xSpeed = 0;
        ySpeed = 0;
        status = 'grabbing-wall';
        var grabbedObject = instance_place(x + sign(image_xscale), y, par_wall);
        if (grabbedObject != noone) {
            ySpeed += (currentFormConstants[? "grav"] - grabbedObject.objectFriction);
        }
        if (key_down == 1) {
            ySpeed *= 4;
        }
        if (key_jump == 1) {
            ySpeed = -currentFormConstants[? "jumpSpeed"];
            
            if (sign(hMove) == -sign(image_xscale)) {
                xSpeed = (currentFormConstants[? "jumpSpeed"]) * -sign(image_xscale);
                image_xscale = -image_xscale;
            } else {
                xSpeed = 2 * -sign(image_xscale);
            }
            
            isGrabingWall = false;
            status = 'jumping';
        }
        if (place_meeting(x, y + 1, par_ground) || grabbedObject == noone) {
            isGrabingWall = false;
        }
    }

}

// Limit Vertical Speed
ySpeed = min(currentFormConstants[? "maxVerticalSpeed"], abs(ySpeed)) * sign(ySpeed);


//////////////////
// Collisions
//////////////////

if (xSpeed != 0) {
    repeat(ceil(abs(xSpeed))){
        collisionObject = instance_place(x + sign(xSpeed), y, par_solid);
        if (collisionObject == noone) {
            x += sign(xSpeed);
        } else {
            bottomCollisionObject = instance_place(x, y + 1, par_solid);
            if (collisionObject.solidType == 'ground' &amp;&amp; collisionObject.isOneWay) {
                x += sign(xSpeed);
            } else if (collisionObject.solidType == 'ground' &amp;&amp; collisionObject.isSlope &amp;&amp; collisionObject.bbox_bottom &gt;= bbox_bottom) {
                x += sign(xSpeed);
                if ((xSpeed &gt; 0 &amp;&amp; collisionObject.leftHeight &gt; collisionObject.rightHeight)
                 || (xSpeed &lt; 0 &amp;&amp; collisionObject.leftHeight &lt; collisionObject.rightHeight)) {
                    var maxHeight = max(collisionObject.leftHeight, collisionObject.rightHeight);
                    for (var i = 0; i &lt; maxHeight; i++) {
                        if (place_meeting(x, y, collisionObject)) {
                            y -= 1;
                        } else {
                            break;
                        }
                    }
                } else {
                    var maxHeight = max(collisionObject.leftHeight, collisionObject.rightHeight);
                    for (var j = 0; j &lt; maxHeight; j++) {
                        if (!place_meeting(x, y, collisionObject)) {
                            y += 1;
                        } else {
                            break;
                        }
                    }
                }
            } else if (bottomCollisionObject != noone &amp;&amp; bottomCollisionObject.solidType == 'ground' &amp;&amp; bottomCollisionObject.isSlope) {
                x += sign(xSpeed);
                for (var i = 0; i &lt; 16; i++) {
                    if (place_meeting(x, y, collisionObject)) {
                        y -= 1;
                    } else {
                        break;
                    }
                }
            }else {
                xSpeed = 0;
                break;
            }
        }
    }
}


if (ySpeed != 0) {
    repeat(ceil(abs(ySpeed))){
        collisionObject = instance_place(x, y + sign(ySpeed), par_solid);
        if (collisionObject == noone) {
            y += sign(ySpeed);
        } else {
            if (collisionObject.solidType == 'ground' &amp;&amp; collisionObject.isOneWay &amp;&amp; collisionObject.bbox_top &lt; bbox_bottom ) {
                y += sign(ySpeed);
            } else {
                ySpeed = 0;
                break;
            }
        }
    }
}

show_debug_message('xSpeed: ');
show_debug_message(xSpeed);
show_debug_message('ySpeed: ');
show_debug_message(ySpeed);
show_debug_message('status: ');
show_debug_message(status);
show_debug_message('----------------');*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update sprite
///////////////////////
/*
if (formList[currentForm] == 'human') {
    
    if (status == 'swimming') {
        if (sprite_index != spr_human_swim) {
            sprite_index = spr_human_swim;
        }
    }
    if (status == 'jumping') {
        if (sprite_index != spr_human_jump) {
            sprite_index = spr_human_jump;
        }
    }
    if (status == 'grabbing-wall') {
        if (sprite_index != spr_human_wall_grab) {
            sprite_index = spr_human_wall_grab;
        }
    }
    if (status == 'falling') {
        if (sprite_index != spr_human_fall) {
            sprite_index = spr_human_fall;
        }
    }
    if (status == 'running') {
        if (sprite_index != spr_human_run) {
            sprite_index = spr_human_run;
        }
    }
    if (status == 'standing') {
        if (sprite_index != spr_human_breath) {
            sprite_index = spr_human_breath;
        }
    }
    if (status == 'sliding') {
        if (sprite_index != spr_human_slide) {
            sprite_index = spr_human_slide;
        }
    }
    if (status == 'crouching') {
        if (sprite_index != spr_human_crouch) {
            sprite_index = spr_human_crouch;
        }
    }
}

if (formList[currentForm] == 'rock') {

    if (status == 'swimming') {
        if (sprite_index != spr_rock_breath) {
            sprite_index = spr_rock_breath;
        }
    }
    if (status == 'jumping') {
        if (sprite_index != spr_rock_breath) {
            sprite_index = spr_rock_breath;
        }
    }

    if (status == 'standing') {
        if (sprite_index != spr_rock_breath) {
            sprite_index = spr_rock_breath;
        }
    }
    
    if (status == 'falling') {
        if (sprite_index != spr_rock_breath) {
            sprite_index = spr_rock_breath;
        }
    }
    if (status == 'running') {
        if (sprite_index != spr_rock_breath) {
            sprite_index = spr_rock_breath;
        }
    }
    
    if (status == 'crouching') {
        if (sprite_index != spr_rock_crouch) {
            sprite_index = spr_rock_crouch;
        }
    }
    
    if (status == 'dashing') {
        if (sprite_index != spr_rock_spin) {
            sprite_index = spr_rock_spin;
        }
    }
}

// direction mirroring
if (hMove == -1 &amp;&amp; image_xscale != -1 &amp;&amp; !isGrabingWall) {
    image_xscale = -1;
}
if (hMove == 1 &amp;&amp; image_xscale != 1 &amp;&amp; !isGrabingWall) {
    image_xscale = 1;
}*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update Camera position
/*moveCamera();*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update Player's Form
/*
if (key_next_form &gt; 0) {
    if (currentForm == (array_length_1d(formList) - 1) ) {
        currentForm = 0;
    } else {
        currentForm += 1;
    }
} else if (key_prev_form &gt; 0) {
    if (currentForm == 0 ) {
        currentForm = array_length_1d(formList) - 1;
    } else {
        currentForm -= 1;
    }
}
currentFormConstants = formConstants[currentForm];

*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Debbuging variables
global.playerObjectState = 'outside';
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>223</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_current_room</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
